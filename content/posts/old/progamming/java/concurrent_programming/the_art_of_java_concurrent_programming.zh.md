---
title: Java 并发编程的艺术
date: 2017-10-13 22:10:00 +0800
tags:
- Java
---

## 并发编程的挑战

### 上下文切换

#### 如何减少上下文切换

+ 无锁并发编程
+ CAS 算法

    + Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要枷锁。

+ 使用最少线程
+ 协程

    + 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

### 死锁

+ 避免死锁的常见方法

    + 避免一个线程同时获取多个锁。
    + 避免一个线程在锁内同时占用多个资源，尽量保证每个锁占用一个资源。
    + 尝试使用定时锁，使用 `lock.tryLock(timeout)` 来替代使用内部锁机制。
    + 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

### 资源限制的挑战

## Java 并发机制的底层实现原理

+ Java 代码在编译后会变成 Java 字节码，字节码被类加载到 JVM 里，JVM 里，JVM 执行字节码，最终需要转化为汇编指令在 CPU 上执行，Java 中所有使用的并发机制依赖于 JVM 的实现和 CPU 的指令。

### volatile 的应用

+ 术语

| 术语    | En                     | 术语描述                                     |
| ----- | ---------------------- | ---------------------------------------- |
| 内存屏障  | memory barriers        | 一组处理器指令，用于实现对内存操作的顺序限制。                  |
| 缓冲行   | cache line             | 缓冲中可以分配的最小存储单元。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存存读周期 |
| 原子操作  | atomic operations      | 不可中断的一个或一系列操作                            |
| 缓冲行填充 | cache line fill        | 当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存。（L1，L2，L3 的或所有） |
| 缓存命中  | cache hit              | 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数而不是从内存读取。 |
| 写命中   | write hit              | 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存。 |
| 写缺失   | write misses the cache | 一个有效的缓存行被写入到不存在的内存区域                     |

+ 缓存一致性协议

+ volatile 两条实现原则

    + Lock 前缀指令会引起处理缓存会写到内存。

        + 在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占任何共享内存。
        + LOCK# 信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。
        + 但在 P6 和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言 LOCK# 信号。
        + 相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性（缓存锁定）
        + 缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。

    + 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。

        + 处理器使用嗅探技术保证他的内部缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。

+ volatile 的使用优化
